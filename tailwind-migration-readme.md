# Міграція VvvebJs з Bootstrap на Tailwind CSS

Цей документ описує процес міграції VvvebJs з Bootstrap CSS на Tailwind CSS. Міграція виконується поступово, зберігаючи сумісність з існуючим кодом.

## Встановлені залежності

- Tailwind CSS (для нового UI фреймворку)
- PostCSS (для обробки Tailwind CSS)
- Autoprefixer (для додавання вендорних префіксів)

## Прогрес міграції

- ✅ Налаштування Tailwind CSS і PostCSS
- ✅ Створення шару сумісності для Bootstrap класів
- ✅ Міграція верхньої панелі (top-panel)
- ✅ Міграція лівої панелі (left-panel)
- ✅ Оновлення системи переключення темної теми
- ✅ Виправлення помилок в роботі JavaScript-функцій
- ⬜ Міграція компонентів правої панелі
- ⬜ Міграція системи сіток
- ⬜ Оновлення всіх компонентів
- ⬜ Видалення залишків Bootstrap

## Реалізація темної теми

Для реалізації темної теми в проєкті використано вбудований механізм Tailwind CSS:

1. **Визначення кольорової схеми**:
   - Використання атрибуту `data-theme` для зберігання поточної теми
   - Використання класів `dark` та `light` на HTML-елементі

2. **Перемикання теми**:
   - Використання кнопки з класом `btn-dark-mode`
   - Збереження вибору користувача в localStorage
   - Автоматичне визначення системних налаштувань через `prefers-color-scheme`

3. **Стилізація елементів**:
   - Використання префікса `dark:` для стилів темної теми (наприклад, `dark:bg-gray-800`)
   - Підтримка як світлої, так і темної теми для всіх компонентів

## Виправлені помилки

- **Помилки null-посилань**: Додані перевірки на null перед доступом до методів і властивостей об'єктів
- **Помилки з кнопкою перемикання теми**: Виправлено функцію darkMode для безпечної роботи з DOM-елементами
- **Проблеми з localStorage**: Покращено роботу з локальним сховищем для налаштувань теми

## Як запустити проєкт

1. Встановіть всі залежності:
   ```
   npm install
   ```

2. Запустіть збірку проєкту:
   ```
   npm run gulp
   ```

3. Запустіть режим спостереження за змінами:
   ```
   npm run gulp watch
   ```

## Структура проєкту після міграції

- `tailwind.config.js` - конфігурація Tailwind CSS
- `postcss.config.js` - конфігурація PostCSS
- `scss/tailwind.scss` - основний файл з Tailwind CSS
- `scss/_bootstrap-mixins-for-tailwind.scss` - міксини для сумісності з Bootstrap
- `css/tailwind.css` - скомпільований CSS файл Tailwind

## Процес міграції

Міграція виконується поступово, в кілька етапів:

1. **Підготовка**: встановлення залежностей, налаштування збірки
2. **Поступова міграція компонентів**: заміна класів Bootstrap на Tailwind
3. **Міграція сіткової системи**: заміна системи сітки Bootstrap на Tailwind
4. **Видалення Bootstrap**: після повної міграції всіх компонентів

Детальний план міграції описано в файлі `migration-strategy.md`.

## Міграція HTML-файлів

При міграції HTML-файлів потрібно замінювати класи Bootstrap на відповідні класи Tailwind. Наприклад:

```html
<!-- Bootstrap -->
<div class="container">
  <div class="row">
    <div class="col-md-6">
      <button class="btn btn-primary">Button</button>
    </div>
  </div>
</div>

<!-- Tailwind CSS -->
<div class="container mx-auto px-4">
  <div class="flex flex-wrap -mx-4">
    <div class="md:w-1/2 px-4">
      <button class="py-2 px-4 bg-blue-500 text-white rounded hover:bg-blue-600">Button</button>
    </div>
  </div>
</div>
```

## Основні відмінності Tailwind від Bootstrap

1. **Утилітарний підхід** - Tailwind використовує утилітарні класи замість компонентних.
2. **Гнучкість** - Tailwind надає більше контролю та можливостей для кастомізації.
3. **Розмір файлу** - Tailwind можна оптимізувати, щоб включати тільки використані класи.
4. **Темна тема** - Tailwind має вбудовану підтримку темної теми через префікс `dark:`.
5. **Адаптивний дизайн** - Tailwind використовує префікси для адаптивності (md:, lg:).

## Таблиця відповідностей

Детальна таблиця відповідностей класів Bootstrap і Tailwind доступна в файлі `migration-strategy.md`.

## Важливі замітки

- В перехідний період обидва фреймворки (Bootstrap і Tailwind) будуть доступні одночасно
- Спочатку замінюйте прості компоненти, поступово переходячи до більш складних
- Пріоритет варто надавати компонентам, які використовуються найчастіше 